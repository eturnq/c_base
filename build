#!/usr/bin/env -S python3 -W ignore::SyntaxWarning

from json import loads as json_load
from pathlib import Path

import subprocess
import sys

buildfile_path = "build.ninja"
current_action = "build"
valid_actions = ["build", "clean", "debug"]

cflags = "cflags = -Wall -Wextra"


def check_for_dependencies():
    required_exe = ["cc", "git", "ninja"]

    for exe in required_exe:
        out = subprocess.run(["which", exe], capture_output=True)
        if out.returncode != 0:
            raise Exception(f"Missing dependency '{exe}'")

    if not Path(".git").is_dir():
        out = subprocess.run(["git", "init"])
        if out.returncode != 0:
            raise Exception("Failed to initialize git repository!")


def git_module_update(module):
    name, repo = (module["name"], module["git"]["remote"])
    git_cmd = ["git", "submodule"]

    if Path(name).is_dir():
        args = git_cmd + ["update", "--remote", "--recursive", name]
        msg = f"Unable to update '{name}'"
    else:
        args = git_cmd + ["add", repo, name]
        msg = f"Unable to install '{name}'"

    out = subprocess.run(args)
    if out.returncode != 0:
        raise Exception(msg)


def local_module_update(module):
    name = module["name"]
    out = subprocess.run(["../build"], cwd=name)
    if out.returncode != 0:
        raise Exception(f"Unable to build local module '{name}'")


def render_build_rule(name, config):
    return f"rule {name}\n  command = {config['command']}"


def src_in_dir(dir, exceptions=[], exception_depth=-1, max_depth=-1):
    if max_depth == 0:
        return []

    src = list(map(lambda x: str(x), dir.glob("*.c")))
    for subdir in dir.iterdir():
        if subdir.is_dir() and not (subdir.name in exceptions and exception_depth > 0):
            [src.append(s) for s in src_in_dir(
                subdir, exceptions, exception_depth - 1, max_depth - 1)]
    return src


def read_buildfile_sources(path):
    with open(path, "r") as file:
        line = file.readline()
        while line:
            if line[:6] == "srcs =":
                return line.split("=")[1].strip().split()
            line = file.readline()
    return []


def render_dependency(tgt, deps, rule):
    dep = " ".join(deps)
    return f"build {tgt}: {rule} {dep}"


def refresh_build_file(config):
    modules = config["modules"] if "modules" in config else []

    c_src = src_in_dir(Path("."), [m["name"] for m in modules], 1)

    objs = [f"{c}.o" for c in c_src]
    lib_dirs = [m["name"] for m in modules]
    lib_paths = [f"{a}/{a}.a" for a in lib_dirs]
    ldflags = [f"-L{a} -l:{a}.a" for a in lib_dirs]
    build_rules = [render_build_rule(n, c)
                   for [n, c] in list(config["rules"].items())]

    buildfile = Path(buildfile_path)
    b_src = read_buildfile_sources(buildfile) if buildfile.is_file() else []
    if len(c_src) == 0:
        raise Exception("No source files found!")

    if set(b_src) != set(c_src):
        print("Refreshing build file...")
        src_text = [" ".join(["srcs", "="] + [str(c) for c in c_src])]
        obj_text = [" ".join(["objs", "="] + objs)]
        ldflags = [" ".join(["ldflags", "="] + ldflags)]
        dep_rules = [render_dependency(
            f"{b}.o", [str(b)], "cc") for b in c_src]
        mod_rules = [render_dependency(
            lib, [lib.split("/")[0]], "module") for lib in lib_paths]
        out_deps = [f"{c}.o" for c in c_src] + lib_paths
        out_rule = [render_dependency(config["name"], out_deps, "link")]

        with open(buildfile_path, "w+") as file:
            lines = src_text + obj_text + \
                [cflags] + ldflags + build_rules + \
                dep_rules + mod_rules + out_rule
            file.write("\n\n".join(lines) + "\n")


def identify_action():
    if len(sys.argv) < 2:
        return

    if sys.argv[1] not in valid_actions:
        raise Exception("Valid actions are {}, or {}".format(
            ", ".join(valid_actions[:-1]), valid_actions[-1]))

    global current_action
    current_action = sys.argv[1]


def execute():
    if current_action == "build" or current_action == "debug":
        args = ["ninja", "-f", buildfile_path]
    elif current_action == "clean":
        args = ["ninja", "-t", "clean"]
    subprocess.run(args)


if __name__ == "__main__":
    identify_action()
    check_for_dependencies()

    with open("build.json", "r") as file:
        config = json_load(file.read())

    if "modules" in config:
        [git_module_update(m) for m in config["modules"] if "git" in m]
        [local_module_update(m) for m in config["modules"] if "local" in m]

    if current_action == "debug":
        cflags += " -DDEBUG_SET"
        buildfile_path = "debug.ninja"

    refresh_build_file(config)
    execute()
